{"name":"Mekano","tagline":"maintain, update and regenerate groups of files","body":"# ![mekano](https://cdn.mediacru.sh/0hecryCVR3vS.svg)\r\n\r\n[![Build Status](https://travis-ci.org/jeanlauliac/mekano.svg?branch=master)](https://travis-ci.org/jeanlauliac/mekano)\r\n\r\nSynopsis\r\n--------\r\n\r\n*mekano(1)* – maintain, update and regenerate groups of files.\r\n\r\n*mekano*:\r\n\r\n  * is a **make-like update tool**: you have a bunch of files in some\r\n    directories, you want to **generate other files** from them, **fast** (no\r\n    unnecessary work);\r\n  * liberally aims to **lessen the frustration** that can occur working with GNU\r\n    *make(1)* on small or medium projects;\r\n  * tries to be balanced between **speed and convenience**;\r\n  * works **best** with a **powerful shell** (like bash & co.), that it does not\r\n    supplant;\r\n  * is **not** tied to any **specific technology** and may be used to compile\r\n    C/C++, build a web application Javascript/CSS assets, or brew your\r\n    coffee.\r\n\r\nExample\r\n-------\r\n\r\nIn `./Mekanofile`:\r\n\r\n    bin = `node_modules/.bin`;\r\n\r\n    Concat: `cat $in > $out`;\r\n    Coffee: `$bin/coffee -cp $in > $out`;\r\n    Minify: `$bin/uglifyjs < $in > $out`;\r\n\r\n    src/**/*.coffee\r\n        Coffee => build/**/*.js\r\n        Concat -> dist/concat.js;\r\n\r\n    dist/*.js\r\n        Minify => dist/*.min.js\r\n        :: all `Update all files`;\r\n\r\nIn your preferred shell:\r\n\r\n    $ ls\r\n    Mekanofile    src\r\n\r\n    $ mekano update\r\n    Updating...  25.0%   Coffee src/foo.coffee -> build/foo.js\r\n    Updating...  50.0%   Coffee src/bar.coffee -> build/bar.js\r\n    Updating...  75.0%   Concat build/foo.js build/bar.js -> dist/concat.js\r\n    Updating... 100.0%   Minify dist/concat.js -> dist/concat.min.js\r\n    Done.\r\n\r\n    $ mekano update\r\n    Everything is up to date.\r\n\r\n    $ ls\r\n    Mekanofile    src      build       dist        .mekano\r\n\r\n    $ ls dist\r\n    concat.js   concat.min.js\r\n\r\n    $ mekano clean\r\n    Removing: dist/concat.min.js\r\n    Removing: dist/concat.js\r\n    Removing: build/foo.js\r\n    Removing: build/bar.js\r\n\r\nDescription\r\n-----------\r\n\r\n*mekano* is a general-purpose update tool. It examines changes made and updates\r\nderived files, called the targets, from the files they are derived, called the\r\nprerequisites. Typical cases include (non-exhaustive):\r\n\r\n  * compiling a group of C/C++ files to their respective object files;\r\n  * linking a group of object files to a single binary;\r\n  * transpiling a plain JavaScript to a minified JavaScript.\r\n\r\nA description file (called mekanofile, or *manifest*) contains a description of\r\nthe relationships between files, and the commands that need to be executed to\r\nupdate the targets and reflect changes in their prerequisites.\r\n\r\n*mekano* focuses above all on correctness and convenience, then speed. It\r\nproperly takes account of removed and added files; tracks command-line changes;\r\nautomatically creates output directories; runs commands concurrently; and\r\nattempts to provide simple semantics for dependency definitions. This tool is\r\nlargely inspired by the\r\n[UNIX *make(1)*](http://pubs.opengroup.org/onlinepubs/009695399/utilities/make.html)\r\nutility, of which it modestly tries to be a 21th-century alternative (not a\r\nreplacement).\r\n\r\n*mekano* only knows how to update files. It is not well suited for so-called\r\n'tasks' (eg. 'test', 'publish'). Plain scripts are probably a better idea for\r\nthose (bash, Javascript, Python…). Using\r\n[npm-scripts](https://www.npmjs.org/doc/misc/npm-scripts.html) or tools like\r\n[grunt](http://gruntjs.com/) is suggested as well.\r\n\r\nThe mekanofile is generally meant to be written by hand, but there is – for now\r\n– very little support for update-time decision-making (no 'if', no macros).\r\nHowever, you can use a dedicaced macro or procedural language to generate\r\nthe mekanofile, like [m4](http://www.gnu.org/software/m4/manual/m4.html),\r\nPython, Javascript…\r\n\r\nThis specific implementation is made with JavaScript on top of Node.js, but keep\r\nin mind it may be usable for any purpose, from C/C++ compilation to web assets\r\nbuild. Node.js just makes it easier to be multiplatform.\r\n\r\nInstall\r\n-------\r\n\r\n**Important:** you need node v0.10 or higher to run this program.\r\n\r\n    $ npm install mekano\r\n\r\nThe tool will be available as `node_modules/.bin/mekano`. It is not recommended\r\nto install it globally, because different projects may need different,\r\nincompatible versions (of course, [semver](http://semver.org/) is used). Is\r\n**is** recommended, however, to add it to your project's `package.json` (just\r\nuse npm's [`--save` option](https://www.npmjs.org/doc/cli/npm-install.html)).\r\n\r\nTo avoid typing the path every time when installed locally, one decent solution\r\nis to create an alias, if your shell supports it. For example:\r\n\r\n    $ alias mk=node_modules/.bin/mekano\r\n\r\nIf you later forget to `npm install` a project, your shell will just tell you:\r\n\r\n    $ mk update\r\n    bash: no such file or directory: node_modules/.bin/mekano\r\n\r\nUsage\r\n-----\r\n\r\n    mekano <command> [options] [bind=value...] [target_name...]\r\n\r\nCommands:\r\n\r\n  * `update` Update the specified targets. The whole project is updated if no\r\n    target is specified.\r\n  * `watch` Keep updating files until a signal is caught. It watches files and\r\n    updates targets when prerequisites change. If the Mekanofile itself changes,\r\n    you need to relaunch mekano manually.\r\n  * `status` Display the modified files and dirty targets. No target is\r\n    updated. If `--silent` is specified, return a zero exit value if the\r\n    targets are up to date; otherwise, return 1.\r\n  * `clean` Remove the specified and dependent targets. For example, with the\r\n    above Mekanofile, `clean dist/concat.js` will remove this file and the\r\n    minified one. All generated files are removed if no target is specified.\r\n  * `aliases` Display a list of the defined aliases.\r\n  * `print <type>` Display the mekanofile interpretation. Types:\r\n      * `manifest` Output the mekanofile as it had been parsed.\r\n      * `dot` Output the file graph in the graphviz dot format.\r\n  * `help` Display mekano own help.\r\n\r\nGeneral options:\r\n\r\n  * `-y, --shy` Stop an update as soon as an error occurs. By default,\r\n    the update continues to get a maximum of errors at once.\r\n  * `-n, --dry-run` Output commands that would be run. No target is updated\r\n    nor deleted.\r\n  * `-f, --file <mekanofile>` Specify a different mekanofile. If `-` is\r\n    specified, the standard input is used.\r\n  * `-r, --robot` Output machine-parseable text.\r\n  * `-v, --version` Output version and exit.\r\n\r\nBinds and target names can be mixed on the command-line, but targets are always\r\nevaluated last. Values cannot refer to values declared inside the mekanofile,\r\nbut the contrary is possible.\r\n\r\nWithout the option `-f`, *mekano* looks in sequence for the files\r\n`./Mekanofile` and `./mekanofile`. The first found is read.\r\n\r\nThe standard output reports the recipes being executed as well as the completion\r\npercentage. The `-r` option makes the output more easily parseable.\r\n\r\nIf any of the SIGHUP, SIGTERM, and SIGQUIT signals is received, the tool stops\r\nupdating but keeps track of updated files so far. However, it does not kill the\r\nrunning sub-processes. If SIGINT (generally Ctrl+C) is received, it follows a\r\n[*\"wait and cooperative exit\"* (WCE)](http://www.cons.org/cracauer/sigint.html)\r\nstategy; it waits for processes to complete, and stops only if they ended on\r\nSIGINT themselves. In **watch** mode, SIGINT only stops the update, if any; a\r\nsecond SIGINT may be needed to quit. For compatibility with sloppy signal\r\nhandlers, return code 130 is also considered a SIGINT.\r\n\r\nAt the moment, Mekano cannot update the Mekanofile itself **and** take account\r\nof it in a single run (with a relation such as\r\n`Mekanofile.in M4 -> Mekanofile`). This is because it won't reload the\r\nMekanofile after its update. You need to run it twice in this case. This will be\r\nimproved in the future.\r\n\r\nSyntax\r\n------\r\n\r\nA mekanofile can contain recipes, relations, and binds. Comments start with\r\n`#`, and end with the next new line. Whitespace is never significant is all\r\nother cases. Statements shall be terminated with `;`, otherwise *mekano* will\r\nnot know the boundary between two successive relations.\r\n\r\n    unit = { recipe | relation | bind }\r\n\r\nThe golden rule when writing a mekanofile is that **order does not matter**.\r\nWhatever the ordering of recipes, relations and binds is, the interpretation\r\nwill always be the same; even if glob patterns are involved. This makes the\r\nsyntax purely declarative.\r\n\r\n### Recipes\r\n\r\nRecipe grammar (in [EBNF](http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form))\r\nis as below:\r\n\r\n    recipe = recipe-name, \":\", command, \";\" ;\r\n    recipe-name = identifier ;\r\n    command = interpolation ;\r\n    identifier = { ? A-Z, a-z, 0-9, '-' or '_' ? }\r\n    interpolation = \"`\", ? any character ?, \"`\" ;\r\n\r\nThere can only be a single command in a recipe. However, multiple processes can\r\nbe launched using the shell operators like `;`, `&&`, `&`, `|` or `||`. The\r\n[pipelines](http://www.gnu.org/software/bash/manual/html_node/Pipelines.html)\r\nare especially useful to avoid creating temporary files (if your shell supports\r\nit). The command can span several lines. Here a simple recipe example:\r\n\r\n    Compile: `gcc -c $in -o $out`;\r\n\r\nBackticks define an *interpolation*. An interpolation can contain the backtick\r\ncharacter when escaped as `` $` ``. `$$` yields a single dollar sign. Command\r\nlines can refer to bound values with `$name` or `$(name)`. The following values\r\nare automatically available during recipe evaluation:\r\n\r\n  * `in` Space-separated shell-quoted list of the input file(s).\r\n  * `out` Space-separated shell-quoted list of the output file(s).\r\n\r\nCommand lines are evaluated by the local shell, typically with `sh -c`.\r\n'UpperCamel' case is suggested for naming recipes. Recipes can appear anywhere\r\nin the mekanofile, either after or before the relations referring to it.\r\n\r\n### Relations\r\n\r\nRelation grammar is as below:\r\n\r\n    relation = ref-list, { transformation }, [ alias ], \";\"\r\n    transformation = recipe-name, ( \"=>\" | \"->\" ), ref-list\r\n    alias = \"::\", alias-name, [ alias-description ]\r\n    ref-list = { path | path-glob | alias-name }\r\n    alias-name = identifier\r\n    alias-description = interpolation\r\n    path = { ? alphanumeric character with at least a '.' or a '/' ? }\r\n    path-glob = { ? same as path, but with at least a '*', '**' or '{,}' operator ? }\r\n\r\nA prerequisite or a target may be either a single file path, a globling pattern,\r\nor an alias. A path always contains one of `/` or `.`, for example `./foo` or\r\n`foo.js` instead of just `foo`; otherwise it is recognized as an alias. Here a\r\nsimple relation example:\r\n\r\n    source/*.c Compile => obj/*.o Link -> ./hello_world\r\n        :: all `Build the hello world program`;\r\n\r\nIt means: *\"takes all the C files in the `source` folder, compile them to object\r\nfiles in `obj`; then link all those into a single binary `./hello_world`. This\r\nbinary can be referred to as the alias `all`.\"*\r\n\r\n#### Expansions\r\n\r\nDuring evaluation, multi-transformation relations are internally expanded to\r\nmultiple single-transformation relations. As such, this statement:\r\n\r\n    foo.c Compile -> foo.o Link -> a.out :: all\r\n\r\nis equivalent to:\r\n\r\n    foo.c Compile -> foo.o\r\n    foo.o Link -> a.out\r\n    a.out :: all\r\n\r\n#### Transformations\r\n\r\nThere are two kind of transformations with *mekano*:\r\n\r\n  * **plain** transformations noted with a simple arrow `->`.\r\n    The recipe is invoked with all the input files, and is assumed to produce\r\n    all the output files.\r\n\r\n  * **generative** transformations noted with a fat arrow `=>`. A plain\r\n    transformation is instantiated for each file matched in the prerequisite\r\n    globbing pattern. For example, if we have two files `foo.c` and `bar.c`,\r\n    the relation:\r\n\r\n        *.c Compile => *.o *.d\r\n\r\n    is interpreted as:\r\n\r\n        foo.c Compile -> foo.o foo.d\r\n        bar.c Compile -> bar.o bar.d\r\n\r\n#### Patterns\r\n\r\nGlobbing patterns can appear both as prerequisites and targets, but yield\r\ndifferent results. Prerequisite patterns expand from two sources:\r\n\r\n  * existing source files matching the pattern;\r\n  * other relations' targets matching the pattern.\r\n\r\n[Minimatch](https://github.com/isaacs/minimatch) is used to match the files.\r\nA prerequisite pattern never matches the targets of the same transformation;\r\nfor example, `dist/*.js Minify => dist/*.min.js` does not create a cycle.\r\n\r\nPatterns as targets can only appear right of generative transformations. For\r\neach prerequisite found, *mekano* performs a pattern transposition. Currently\r\nthe system is pretty limited and only the symbols `**` and `*` are accounted\r\nfor: it copies everything from the left of the first start, and right of the\r\nlast star.\r\n\r\nFor example, for a relation `src/**/*.c Compile => obj/**/*.o`, if a file\r\n`src/a/foo.c` was found, the target pattern is expanded to `obj/a/foo.o`.\r\nOn the other hand, a pattern like `src/**/foo/*.c` won't work properly\r\nbecause `/foo/` will be lost in the process.\r\n\r\nGenerative pattern transposition is planned to be hugely improved in the future.\r\n\r\n### Binds\r\n\r\nValue bind grammar is as below:\r\n\r\n    bind = value-name, \"=\", interpolation, \";\"\r\n    value-name = identifier\r\n\r\nA value cannot be unbound or overridden, but can be rebound in inner scopes.\r\nInterpolations can refer to existing values with `$name` or `$(name)`. Example:\r\n\r\n    bin = `node_module/.bin`;\r\n    coffee = `$bin/coffee`;\r\n\r\nA bound value is available anywhere in the mekanofile, even before the\r\ndeclaration. The order of declaration does not matter; but you cannot have\r\ncircular references.\r\n\r\nFile update\r\n-----------\r\n\r\nOnce the mekanofile has been read, *mekano* executes the steps below.\r\n\r\n  * Build a graph of all the files according with the relations.\r\n  * Topologically sort the files considering their dependencies.\r\n  * Determine the *imprint* of each file involved. The imprint is a\r\n    [MurmurHash](http://en.wikipedia.org/wiki/MurmurHash) accounting for a\r\n    file prerequisites and timestamp.\r\n  * Determine which transformations are needed to be run by comparing imprints\r\n    to the update log generated by the previous run of *mekano*, if any.\r\n  * Remove *orphans*: old generated files that are not in the graph anymore.\r\n  * Invoke recipes in order to update files. When possible, recipes are\r\n    called asynchronously to make the update faster.\r\n\r\nAny output directory containing targets is automatically created by *mekano*\r\nduring the update.\r\n\r\nThe update log is located in `.mekano/log.json` and contains the imprint of\r\neach generated file. **Never delete the log file!** To do a whole rebuild, use\r\nthe **clean** command instead. If you delete the log, bad things will\r\nhappen, because *mekano* will consider all the generated files so far as\r\nsources. This means, for example, that minified files (`foo.min.js`) will be\r\nminified again (`foo.min.min.js`).\r\n\r\nWhen you are using a version control tool, like **git(1)**: if you are\r\nadding built files to the repository (and not just the sources), then you\r\nshall add the log file as well. Otherwise, people checking out the repo.\r\nwill get trouble because *mekano* won't know which file is generated and which\r\nis not.\r\n\r\nKnown limitations\r\n----------------\r\n\r\nIt is generally planned to improve upon those limitations.\r\n\r\n  * pattern transposition for generative transformations is very basic;\r\n  * no dependency-only prerequisites, no parsing of preprocessors dependency\r\n    files (eg. [`gcc -MM`](http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Preprocessor-Options.html));\r\n  * no recipe-specific or transformation-specific binds;\r\n  * a bug appears, for the command `watch' only, when a\r\n    [file is renamed](https://github.com/shama/gaze/issues/107);\r\n  * generative transformations accept only one pattern prerequisite.\r\n\r\nSee also the [ROADMAP](./ROADMAP.md).\r\n\r\nTrivia\r\n------\r\n\r\n### Why using this instead of make?\r\n\r\n  * It may be simpler to set up transformation of multiple files, with no need\r\n    to write a list of files or use macros like `$(wildcard *.foo)`;\r\n  * directories are handled automatically;\r\n  * it detects command line changes;\r\n  * it can watch files out-of-the-box;\r\n  * it also runs concurrently (GNU Make's `-j` option).\r\n\r\n### Why using this instead of grunt?\r\n\r\n  * Minimal updates: files that did not change do not trigger update;\r\n  * no plugin system, you can use tools from any package, in any version; 'less\r\n    is more' applies pretty well to this case;\r\n  * concurrency.\r\n\r\n### Why *not* using mekano?\r\n\r\n  * it's still in beta and may be unstable;\r\n  * too high-level, you have specific dependency needs;\r\n  * no logic, no 'if', limited semantics;\r\n  * might be too slow for medium or large projects.\r\n\r\n### Why not reusing the make syntax?\r\n\r\nThe classic *make* syntax \"targets: prerequisites\" is not employed because:\r\n\r\n  * it may not be very clear how to express transformation chains (something\r\n    like `foo: bar: glo`?);\r\n  * inference is done the other way around than *make* (it infers targets based\r\n    on prerequisites; make does the opposite with rules like `%.o: %c`).\r\n\r\n### Shout out\r\n\r\nTo the masters from which *mekano* is inspired:\r\n\r\n  * the historic [GNU make](http://www.gnu.org/software/make/manual/make.html);\r\n  * the fast [Ninja](http://martine.github.io/ninja/);\r\n  * the cutting-edge [tup](http://gittup.org/tup/);\r\n  * the down-to-earth [grunt](http://gruntjs.com/).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}